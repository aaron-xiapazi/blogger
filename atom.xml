<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾爬子的Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://createralan.github.io/"/>
  <updated>2021-03-31T05:53:05.905Z</updated>
  <id>https://createralan.github.io/</id>
  
  <author>
    <name>Tongziqi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux命令行 (三) 事件处理</title>
    <link href="https://createralan.github.io/2020/05/16/linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E4%B8%89-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>https://createralan.github.io/2020/05/16/linux命令行-三-事件处理/</id>
    <published>2020-05-16T21:01:02.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>一切源自于一篇文章</p><p><strong>Command-line Tools can be 235x Faster than your Hadoop Cluster</strong></p><p>命令行比集群快235倍？？？</p><p>也许这个说法有些夸大，或者只针对于小部分情况，但是它真实存在。</p><p>今天以一个例子来说明如果使用命令行处理事件。</p><h1 id="事件样例"><a href="#事件样例" class="headerlink" title="事件样例"></a>事件样例</h1><p>数据源：一个2G大小的数据，里面包含了100M场围棋棋局。以下是数据格式。</p><p>数据地址：github：rozim/ChessData</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Event "F/S Return Match"]</span><br><span class="line">[Site "Belgrade, Serbia Yugoslavia|JUG"]</span><br><span class="line">[Date "1992.11.04"]</span><br><span class="line">[Round "29"]</span><br><span class="line">[White "Fischer, Robert J."]</span><br><span class="line">[Black "Spassky, Boris V."]</span><br><span class="line">[Result "1/2-1/2"]</span><br><span class="line">(moves from the game follow...)</span><br></pre></td></tr></table></figure><p>目标：有n个pgn文件里面包含了以上数据格式的复盘数据，每个文件中包含了n个棋局，数据中Result代表黑白棋的输赢，”[黑-白]”。<strong>统计白棋、黑棋、和局次数。</strong></p><p>一共有三种方式：</p><ul><li><h3 id="v1-最简版"><a href="#v1-最简版" class="headerlink" title="v1 最简版"></a>v1 最简版</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat *.pgn | grep <span class="string">"Result"</span> | sort | uniq -c</span><br></pre></td></tr></table></figure><p>cat *.pgn : 查看所有pgn格式的文件（文件数量上限通过 $ getconf ARG_MAX 查找）</p><p>grep “Result”： 搜索所有Result所在行</p><p>sort ：排序（时间复杂度O（nlogn），空间复杂度O（n））</p><p>uniq -c :统计每个独立行出现的次数，仅对已排序文件有效（时间复杂度O（n），空间复杂度O（1））</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//结果样例</span><br><span class="line">$ cat *.pgn |grep <span class="string">"Result"</span>| sort | uniq -c</span><br><span class="line">    159 [Result <span class="string">"*"</span>]</span><br><span class="line"> 839724 [Result <span class="string">"0-1"</span>]</span><br><span class="line"> 966394 [Result <span class="string">"1/2-1/2"</span>]</span><br><span class="line">1085486 [Result <span class="string">"1-0"</span>]</span><br></pre></td></tr></table></figure><ul><li><h3 id="v2-优化版"><a href="#v2-优化版" class="headerlink" title="v2 优化版"></a>v2 优化版</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat *.pgn | grep <span class="string">"Result"</span> | awk <span class="string">'&#123; split($0, a, "-"); res = substr(a[1], length(a[1]), 1); if (res == 1) white++; if (res == 0) black++; if (res == 2) draw++;&#125; END &#123; print white+black+draw, white, black, draw &#125;'</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="v3-多线程版"><a href="#v3-多线程版" class="headerlink" title="v3 多线程版"></a>v3 多线程版</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">'*.pgn'</span> -print0 | xargs -0 -n1 -P8 mawk <span class="string">'/Result/ &#123; split($0, a, "-"); res = substr(a[1], length(a[1]), 1); if (res == 1) white++; if (res == 0) black++; if (res == 2) draw++ &#125; END &#123; print white+black+draw, white, black, draw &#125;'</span> | awk <span class="string">'&#123;games += $1; white += $2; black += $3; draw += $4; &#125; END &#123; print games, white, black, draw &#125;'</span></span><br></pre></td></tr></table></figure><p><img src="https://zxi.mytechroad.com/blog/wp-content/uploads/2020/05/cmd-3-12.png" alt="img"></p><h1 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h1><ul><li>管道中的命令如果没有依赖关系会并行执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 3| slepp 5 | <span class="built_in">echo</span> <span class="string">'8'</span></span><br></pre></td></tr></table></figure><p>会先输出8，过8s多一点点会命令结束</p><ul><li>查看磁盘读取时间: time</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time cat*.pgn &gt; /dev/null</span><br></pre></td></tr></table></figure><ul><li>sort排序</li></ul><p>对文本排序，会把所有数据读入内存，如果内存存不下会写入临时文件中</p><p>感谢：</p><blockquote><p>原文地址：<a href="https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html" target="_blank" rel="noopener">https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html</a></p></blockquote><blockquote><p>技术原文：<a href="https://zxi.mytechroad.com/blog/category/linux/" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/category/linux/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一切源自于一篇文章&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Command-line Tools can be 235x Faster than your Hadoop Cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令行比集群快235倍？？？&lt;/p&gt;
&lt;p&gt;也许这个说法有些夸大，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA编程基础 （四） switch字符串</title>
    <link href="https://createralan.github.io/2020/04/25/JAVA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-%EF%BC%88%E5%9B%9B%EF%BC%89-switch%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://createralan.github.io/2020/04/25/JAVA编程基础-（四）-switch字符串/</id>
    <published>2020-04-25T23:30:07.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>switch</strong> 有时也被划归为一种选择语句。根据整数表达式的值，<strong>switch</strong> 语句可以从一系列代码中选出一段去执行。它的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value4 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value5 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>integral-selector是一个能够产生整数值的表达式，switch能够将整个整个表达式的结果与每个integral-value相比较，若发现相符的，就执行对应的语句，没有发现就执行default语句</p><h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><p>Java7 加上可字符串switch的用法，下面展示一组传统方法及新方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/StringSwitch.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSwitch</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="comment">// 老的方式: 使用 if-then 判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"red"</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"RED"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"green"</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"GREEN"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"blue"</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"BLUE"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"yellow"</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"YELLOW"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Unknown"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的方法: 字符串搭配 switch</span></span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"red"</span>:</span><br><span class="line">        System.out.println(<span class="string">"RED"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"green"</span>:</span><br><span class="line">        System.out.println(<span class="string">"GREEN"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"blue"</span>:</span><br><span class="line">        System.out.println(<span class="string">"BLUE"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"yellow"</span>:</span><br><span class="line">        System.out.println(<span class="string">"YELLOW"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"Unknown"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦理解了 <strong>switch</strong>，你会明白这其实就是一个逻辑扩展的语法糖。新的编码方式能使得结果更清晰，更易于理解和维护。</p><p>作为 <strong>switch</strong> 字符串的第二个例子，我们重新访问 <code>Math.random()</code>。 它是否产生从 0 到 1 的值，包括还是不包括值 1 呢？在数学术语中，它属于 (0,1)、 [0,1)、(0,1] 、[0,1] 中的哪种呢？（方括号表示“包括”，而括号表示“不包括”）</p><p>下面是一个可能提供答案的测试程序。 所有命令行参数都作为 <strong>String</strong> 对象传递，因此我们可以 <strong>switch</strong> 参数来决定要做什么。 那么问题来了：如果用户不提供参数 ，索引到 <code>args</code> 的数组就会导致程序失败。 解决这个问题，我们需要预先检查数组的长度，若长度为 0，则使用<strong>空字符串</strong> <code>&quot;&quot;</code> 替代；否则，选择 <code>args</code> 数组中的第一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control/RandomBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.random() 会产生 0.0 和 1.0 吗？</span></span><br><span class="line"><span class="comment">// &#123;java RandomBounds lower&#125;</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomBounds</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span>(args.length == <span class="number">0</span> ? <span class="string">""</span> : args[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"lower"</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">0.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">"Produced 0.0!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"upper"</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">1.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">"Produced 1.0!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"Usage:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"\tRandomBounds lower"</span>);</span><br><span class="line">        System.out.println(<span class="string">"\tRandomBounds upper"</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要运行该程序，请键入以下任一命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java RandomBounds lower </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">java RandomBounds upper复制ErrorOK!</span><br></pre></td></tr></table></figure><p>使用 <code>onjava</code> 包中的 <strong>TimedAbort</strong> 类可使程序在三秒后中止。从结果来看，似乎 <code>Math.random()</code> 产生的随机值里不包含 0.0 或 1.0。 这就是该测试容易混淆的地方：若要考虑 0 至 1 之间所有不同 <strong>double</strong> 数值的可能性，那么这个测试的耗费的时间可能超出一个人的寿命了。 这里我们直接给出正确的结果：<code>Math.random()</code> 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1）来表示。由此可知，我们必须小心分析实验并了解它们的局限性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;switch&lt;/strong&gt; 有时也被划归为一种选择语句。根据整数表达式的值，&lt;strong&gt;switch&lt;/strong&gt; 语句可以从一系列代码中选出一段去执行。它的格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （十五） 接口优于抽象类</title>
    <link href="https://createralan.github.io/2020/04/21/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%20%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://createralan.github.io/2020/04/21/高效java-（十五）-接口优于抽象类 接口优于抽象类/</id>
    <published>2020-04-21T19:07:09.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h1><p>　　Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9.4.3] 中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。</p><p>　　现有的类可以很容易地进行改进来实现一个新的接口。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个 <code>implements</code> 子句。 例如，当 <code>Comparable</code>, <code>Iterable</code>， 和 <code>Autocloseable</code> 接口添加到 Java 平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。</p><p>　　接口是定义混合类型（mixin）的理想选择。 一般来说，mixin 是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，<code>Comparable</code> 是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。</p><p>　　接口允许构建非层级类型的框架。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，和另一个代表作曲家的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">    <span class="function">AudioClip <span class="title">sing</span><span class="params">(Song s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Songwriter</span> </span>&#123;</span><br><span class="line">    <span class="function">Song <span class="title">compose</span><span class="params">(<span class="keyword">int</span> chartPosition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingerSongwriter</span> <span class="keyword">extends</span> <span class="title">Singer</span>, <span class="title">Songwriter</span> </span>&#123;</span><br><span class="line">    <span class="function">AudioClip <span class="title">strum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actSensitive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有 n 个属性，则可能需要支持 2n 种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。</p><p>　　接口通过包装类模式确保安全的，强大的功能增强成为可能（条目 18）。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。</p><p>　　当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第 104 页的 <code>removeIf</code> 方法。如果提供默认方法，请确保使用<code>@implSpec</code> Javadoc 标记（条目 19）将它们文档说明为继承。</p><p>　　使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了 <code>Object</code> 类中方法（如 <code>equals</code> 和 <code>hashCode</code>）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。</p><p>　　但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。</p><p>　　按照惯例，骨架实现类被称为 <code>AbstractInterface</code>，其中 <code>Interface</code> 是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：<code>AbstractCollection</code>，<code>AbstractSet</code>，<code>AbstractList</code> 和 <code>AbstractMap</code>。 可以说，将它们称为 <code>SkeletalCollection</code>，<code>SkeletalSet</code>，<code>SkeletalList</code> 和 <code>SkeletalMap</code> 是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在 <code>AbstractList</code> 的顶层包含一个完整的功能齐全的 <code>List</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Concrete implementation built atop skeletal implementation</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">intArrayAsList</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(a);</span><br><span class="line">    <span class="comment">// The diamond operator is only legal here in Java 9 and later</span></span><br><span class="line">    <span class="comment">// If you're using an earlier release, specify &lt;Integer&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractList&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[i];  <span class="comment">// Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6))</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, Integer val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> oldVal = a[I];</span><br><span class="line">            a[i] = val;     <span class="comment">// Auto-unboxing</span></span><br><span class="line">            <span class="keyword">return</span> oldVal;  <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当你考虑一个 <code>List</code> 实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter）[Gamma95]，它允许一个 <code>int</code> 数组被看作 <code>Integer</code> 实例列表。 由于 <code>int</code> 值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（条目 24）。</p><p>　　骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18 讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。</p><p>　　编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如 <code>Object</code> 类中 <code>equals</code> 和 <code>hashCode</code> 等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。</p><p>　　作为一个简单的例子，考虑一下 <code>Map.Entry</code> 接口。 显而易见的基本方法是 <code>getKey</code>，<code>getValue</code> 和（可选的）<code>setValue</code>。 接口指定了 <code>equals</code> 和 <code>hashCode</code> 的行为，并且在基本方面方面有一个 <code>toString</code> 的明显的实现。 由于不允许为 <code>Object</code> 类方法提供默认实现，因此所有实现均放置在骨架实现类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Skeletal implementation class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entries in a modifiable map must override this method</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.equals</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(e.getKey(),  getKey())</span><br><span class="line">            &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implements the general contract of Map.Entry.hashCode</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey())</span><br><span class="line">             ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　请注意，这个骨架实现不能在 <code>Map.Entry</code> 接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如 <code>equals</code>，<code>hashCode</code> 和 <code>toString</code> 等 <code>Object</code> 类方法。</p><p>　　由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19 中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是好的文档在骨架实现中是绝对必要的，无论它是否包含 一个接口或一个单独的抽象类的默认方法。</p><p>　　与骨架实现有稍许不同的是简单实现，以 <code>AbstractMap.SimpleEntry</code> 为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。</p><p>　　总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口优于抽象类&quot;&gt;&lt;a href=&quot;#接口优于抽象类&quot; class=&quot;headerlink&quot; title=&quot;接口优于抽象类&quot;&gt;&lt;/a&gt;接口优于抽象类&lt;/h1&gt;&lt;p&gt;　　Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （十四） 如使用继承设计，应当文档说明</title>
    <link href="https://createralan.github.io/2020/04/20/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89-%E5%A6%82%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%BA%94%E5%BD%93%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"/>
    <id>https://createralan.github.io/2020/04/20/高效java-（十四）-如使用继承设计，应当文档说明/</id>
    <published>2020-04-20T22:20:20.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="19-如使用继承则设计，应当文档说明，否则不该使用"><a href="#19-如使用继承则设计，应当文档说明，否则不该使用" class="headerlink" title="19. 如使用继承则设计，应当文档说明，否则不该使用"></a>19. 如使用继承则设计，应当文档说明，否则不该使用</h1><p>　　首先，这个类必须准确地描述重写这个方法带来的影响。 换句话说，该类必须文档说明可重写方法的自用性（self-use）。 对于每个公共或受保护的方法，文档必须指明方法调用哪些重写方法，以何种顺序以及每次调用的结果如何影响后续处理。 （重写方法，这里是指非 <code>final</code> 修饰的方法，无论是公开还是保护的。）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。 例如，后台线程或者静态初始化代码块可能会调用这样的方法。</p><p>　　调用可重写方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为“Implementation Requirements”，由 Javadoc 标签 <code>@implSpec</code> 生成。 本节介绍该方法的内部工作原理。 下面是从 <code>java.util.AbstractCollection</code> 类的规范中拷贝的例子：</p><p>　　从该集合中删除指定元素的单个实例（如果存在，optional 实例操作）。 更正式地说，如果这个集合包含一个或多个这样的元素，删除使得 <code>Objects.equals(o, e)</code> 的一个元素 e。 如果此集合包含指定的元素（或者等同于此集合因调用而发生了更改），则返回 true。</p><p>　　<strong>实现要求：</strong> 这个实现迭代遍历集合查找指定元素。 如果找到元素，则使用迭代器的 <code>remove</code> 方法从集合中删除元素。 请注意，如果此集合的 <code>iterator</code> 方法返回的迭代器未实现 <code>remove</code> 方法，并且此集合包含指定的对象，则此实现将引发 <code>UnsupportedOperationException</code> 异常。</p><p>　　这个文档毫无疑问地说明，重写 <code>iterator</code> 方法会影响 <code>remove</code> 方法的行为。 它还描述了 <code>iterator</code> 方法返回的 <code>Iterator</code> 行为将如何影响 <code>remove</code> 方法的行为。 与条目 18 中的情况相反，在这种情况下，程序员继承 HashSet 并不能说明重写 <code>add</code> 方法是否会影响 <code>addAll</code> 方法的行为。</p><p>　　但是，这是否违背了一个良好的 API 文档应该描述给定的方法是什么，而不是它是如何做的呢？ 是的，它确实！这是继承违反封装这一事实的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。</p><p>　　<code>@implSpec</code> 标签是在 Java 8 中添加的，并且在 Java 9 中被大量使用。这个标签应该默认启用，但是从 Java 9 开始，除非通过命令行开关<code>-tag &quot;apiNote:a:API Note:&quot;</code>，否则 Javadoc 实用工具仍然会忽略它。</p><p>　　设计继承涉及的不仅仅是文档说明自用的模式。 为了让程序员能够写出有效的子类而不会带来不适当的痛苦，一个类可能以明智选择的受保护方法的形式提供内部工作，或者在罕见的情况下，提供受保护的属性。 例如，考虑 <code>java.util.AbstractList</code> 中的 <code>removeRange</code> 方法：</p><p>　　从此列表中删除索引介于 <code>fromIndex</code>（包含）和 <code>inclusive</code>（不含）之间的所有元素。 将任何后续元素向左移（减少索引）。 这个调用通过（<code>toIndex - fromIndex</code>）元素来缩短列表。 （如果 <code>toIndex == fromIndex</code>，则此操作无效。）</p><p>　　这个方法是通过列表及其子类的 <code>clear</code> 操作来调用的。重写这个方法利用列表内部实现的优势，可以大大提高列表和子类的 <code>clear</code> 操作性能。</p><p>　　实现要求：这个实现获取一个列表迭代器，它位于 <code>fromIndex</code> 之前，并重复调用 <code>ListIterator.remove</code> 和 <code>ListIterator.next</code> 方法，直到整个范围被删除。 注意：如果 <code>ListIterator.remove</code> 需要线性时间，则此实现需要平方级时间。</p><blockquote><p>参数：<br>　　fromIndex 要移除的第一个元素的索引<br>　　toIndex 要移除的最后一个元素之后的索引</p></blockquote><p>　　这个方法对 <code>List</code> 实现的最终用户来说是没有意义的。 它仅仅是为了使子类很容易提供一个快速 <code>clear</code> 方法。 在没有 <code>removeRange</code> 方法的情况下，当在子列表上调用 <code>clear</code> 方法，子类将不得不使用平方级的时间，否则，或从头重写整个 <code>subList</code> 机制——这不是一件容易的事情！</p><p>　　那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？ 不幸的是，没有灵丹妙药。 所能做的最好的就是努力思考，做出最好的测试，然后通过编写子类来进行测试。 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。</p><p>　　<strong>测试为继承而设计的类的唯一方法是编写子类。</strong> 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。 相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。</p><p>　　当你为继承设计一个可能被广泛使用的类的时候，要意识到你永远承诺你文档说明的自用模式以及隐含在其保护的方法和属性中的实现决定。 这些承诺可能会使后续版本中改善类的性能或功能变得困难或不可能。 因此， <strong>在发布它之前，你必须通过编写子类来测试你的类。</strong></p><p>　　另外，请注意，继承所需的特殊文档混乱了正常的文档，这是为创建类的实例并在其上调用方法的程序员设计的。 在撰写本文时，几乎没有工具将普通的 API 文档从和仅仅针对子类实现的信息，分离出来。</p><p>　　还有一些类必须遵守允许继承的限制。 <strong>构造方法绝不能直接或间接调用可重写的方法。</strong> 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。 为了具体说明，这是一个违反这个规则的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken - constructor invokes an overridable method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　以下是一个重写 <code>overrideMe</code> 方法的子类，<code>Super</code> 类的唯一构造方法会错误地调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Blank final, set by constructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instant instant;</span><br><span class="line"></span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant = Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overriding method invoked by superclass constructor</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overrideMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　你可能期望这个程序打印两次 <code>instant</code> 实例，但是它第一次打印出 <code>null</code>，因为在 <code>Sub</code> 构造方法有机会初始化 <code>instant</code> 属性之前，<code>overrideMe</code> 被 <code>Super</code> 构造方法调用。 请注意，这个程序观察两个不同状态的 <code>final</code> 属性！ 还要注意的是，如果 <code>overrideMe</code> 方法调用了 instant 实例中任何方法，那么当父类构造方法调用 <code>overrideMe</code> 时，它将抛出一个 <code>NullPointerException</code> 异常。 这个程序不会抛出 <code>NullPointerException</code> 的唯一原因是 <code>println</code> 方法容忍 <code>null</code> 参数。</p><p>　　请注意，从构造方法中调用私有方法，其中任何一个方法都不可重写的，那么 <code>final</code> 方法和静态方法是安全的。</p><p>　　<code>Cloneable</code> 和 <code>Serializable</code> 接口在设计继承时会带来特殊的困难。 对于为继承而设计的类来说，实现这些接口通常不是一个好主意，因为这会给继承类的程序员带来很大的负担。 然而，可以采取特殊的行动来允许子类实现这些接口，而不需要强制这样做。 </p><p>　　如果你决定在为继承而设计的类中实现 <code>Cloneable</code> 或 <code>Serializable</code> 接口，那么应该知道，由于 <code>clone</code> 和 <code>readObject</code> 方法与构造方法相似，所以也有类似的限制： <strong><code>clone</code> 和 <code>readObject</code> 都不会直接或间接调用可重写的方法。</strong> 在 <code>readObject</code> 的情况下，重写方法将在子类的状态被反序列化之前运行。 在 <code>clone</code> 的情况下，重写方法将在子类的 <code>clone</code> 方法有机会修复克隆的状态之前运行。 在任何一种情况下，都可能会出现程序故障。 在 <code>clone</code> 的情况下，故障可能会损坏原始对象以及被克隆对象本身。 例如，如果重写方法假定它正在修改对象的深层结构的拷贝，但是尚未创建拷贝，则可能发生这种情况。</p><p>　　最后，如果你决定在为继承设计的类中实现 <code>Serializable</code> 接口，并且该类有一个 <code>readResolve</code> 或 <code>writeReplace</code> 方法，则必须使 <code>readResolve</code> 或 <code>writeReplace</code> 方法设置为受保护而不是私有。 如果这些方法是私有的，它们将被子类无声地忽略。 这是另一种情况，把实现细节成为类的 API 的一部分，以允许继承。</p><p>　　到目前为止，<strong>设计一个继承类需要很大的努力，并且对这个类有很大的限制。</strong> 这不是一个轻率的决定。 有些情况显然是正确的，比如抽象类，包括接口的骨架实现（skeletal implementations）（条目 20）。 还有其他的情况显然是错误的，比如不可变的类。</p><p>　　但是普通的具体类呢？ 传统上，它们既不是 <code>final</code> 的，也不是为了子类化而设计和文档说明的，但是这种情况是危险的。每次修改这样的类，则继承此类的子类将被破坏。 这不仅仅是一个理论问题。 在修改非 <code>final</code> 的具体类的内部之后，接收与子类相关的错误报告并不少见，这些类没有为继承而设计和文档说明。</p><p>　　<strong>解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化。 有两种方法禁止子类化。</strong> 两者中较容易的是声明类为 <code>final</code>。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类的灵活性，在条目 17 中讨论过。两种方法都是可以接受的。</p><p>　　这个建议可能有些争议，因为许多程序员已经习惯于继承普通的具体类来增加功能，例如通知和同步等功能，或限制原有类的功能。 如果一个类实现了捕获其本质的一些接口，比如 <code>Set</code>，<code>List</code> 或 <code>Map</code>，那么不应该为了禁止子类化而感到愧疚。 在条目 18 中描述的包装类模式为增强功能提供了继承的优越选择。</p><p>　　如果一个具体的类没有实现一个标准的接口，那么你可能会通过禁止继承来给一些程序员带来不便。 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。 这样做，你将创建一个合理安全的子类。 重写一个方法不会影响任何其他方法的行为。</p><p>　　你可以机械地消除类的自我使用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移动到一个私有的“帮助器方法”，并让每个可重写的方法调用其私有的帮助器方法。 然后用直接调用可重写方法的专用帮助器方法来替换每个自用的可重写方法。</p><p>　　总之，设计一个继承类是一件很辛苦的事情。 你必须文档说明所有的自用模式，一旦你文档说明了它们，必须承诺为他们的整个生命周期。 如果你不这样做，子类可能会依赖于父类的实现细节，并且如果父类的实现发生改变，子类可能会损坏。 为了允许其他人编写高效的子类，可能还需要导出一个或多个受保护的方法。 除非你知道有一个真正的子类需要，否则你可能最好是通过声明你的类为 <code>final</code> 禁止继承，或者确保没有可访问的构造方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;19-如使用继承则设计，应当文档说明，否则不该使用&quot;&gt;&lt;a href=&quot;#19-如使用继承则设计，应当文档说明，否则不该使用&quot; class=&quot;headerlink&quot; title=&quot;19. 如使用继承则设计，应当文档说明，否则不该使用&quot;&gt;&lt;/a&gt;19. 如使用继承则
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （十三） 优选选择对象组合而不是继承</title>
    <link href="https://createralan.github.io/2020/04/19/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89-%E4%BC%98%E9%80%89%E9%80%89%E6%8B%A9%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <id>https://createralan.github.io/2020/04/19/高效java-（十三）-优选选择对象组合而不是继承/</id>
    <published>2020-04-19T17:27:18.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>使用继承实现代码复用很强大的方法。</p><p>在同一个包中由程序员控制子类和超类也是安全的，但是对于普通的具体类进行跨包边界的继承是危险的。</p><p>（本文暂不讨论接口继承）</p><h2 id="继承-破坏了封装"><a href="#继承-破坏了封装" class="headerlink" title="继承-破坏了封装"></a>继承-破坏了封装</h2><p>子类的功能正常与否依赖于它的超类的实现细节。超类的实现可能在版本之间发生变化，如果发生了变化，子类可能会崩溃，即使子类的代码没有被修改过。子类必须与其超类同步发展，除非超类是专门为扩展所设计的。</p><p>我们以HashSet举一个例子</p><p>继承HashSet 且覆盖add ，addAll两个方法，getAddCount返回Set中的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Broken - Inappropriate use of inheritance!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The number of attempted element insertions</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">(<span class="keyword">int</span> initCap, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; s = <span class="keyword">new</span> InstrumentedHashSet&lt;&gt;();</span><br><span class="line">s.addAll(Arrays.asList(<span class="string">"Snap"</span>, <span class="string">"Crackle"</span>, <span class="string">"Pop"</span>));</span><br><span class="line">System.out.println(s.getAddCount());</span><br></pre></td></tr></table></figure><p>我们希望此处getAddCount（）返回的是3 ，但会返回6 ，到底是哪里出错了？</p><p><strong>在内部，HashSet 的 addAll 方法是在其 add 方法之上实现的，尽管 HashSet 相当合理地没有记录这个实现细节。InstrumentedHashSet 中的 addAll 方法向 addCount 添加了三个元素，然后使用 <code>super.addAll</code> 调用 HashSet 的 addAll 实现。这反过来调用 add 方法（在 InstrumentedHashSet 中被覆盖），每个元素一次。这三个调用中的每一个都向 addCount 添加了一个元素，总共增加了 6 个元素：使用 addAll 方法添加的每个元素都被重复计数。</strong></p><p>我们可以通过消除 addAll 方法的覆盖来「修复」子类。虽然生成的类可以工作，但它的正确功能取决于 HashSet 的 addAll 方法是在 add 方法之上实现的事实。这种「自用」是实现细节，不能保证在 Java 平台的所有实现中都存在，也不能保证在版本之间进行更改。因此，结果得到的 InstrumentedHashSet 类是脆弱的。</p><p>覆盖 addAll 方法以遍历指定的集合稍微好一些，为每个元素调用一次 add 方法。无论 HashSet 的 addAll 方法是否在其 add 方法之上实现，这都将保证正确的结果，因为 HashSet 的 addAll 实现将不再被调用。然而，这种技术并不能解决我们所有的问题。它相当于重新实现超类方法，这可能会导致「自用」，也可能不会，这是困难的、耗时的、容易出错的，并且可能会降低性能。此外，这并不总是可能的，因为如果不访问子类无法访问的私有字段，就无法实现某些方法。</p><p>还好我们有一个方法可以避免以上问题!</p><h2 id="对象组合"><a href="#对象组合" class="headerlink" title="对象组合"></a>对象组合</h2><p><em>有时也成为复合、聚合、包容等</em></p><ul><li>组合是一种通过创建一个组合了其他的对象，从而获得新功能的复用方法</li><li><p>将功能委托给所组合的一个对象，从而获得新功能</p></li><li><p>优点</p><ol><li>容器类仅能通过被包含对象的接口来对其进行访问</li><li>黑盒复用，因为被包含对象的内部细节对外是不可见的</li><li>实现上的相互依赖性比较小</li><li>每一个类只专注于一项任务</li><li>通过获取指向其他的具有相同类型的对象引用，可以在运行期间动态地定义组合</li></ol></li><li><p>缺点</p><ol><li>导致系统中的对象过多</li><li>为了能将多个不同的对象作为组合块（composition block）来使用，必须仔细地对接口进行定义。</li></ol></li></ul><p>现有的类是新类的一个组件。新类中的每个实例方法调用现有类的包含实例上的对应方法，并返回结果。这称为转发，新类中的方法称为转发方法。生成的类将非常坚固，不依赖于现有类的实现细节。即使向现有类添加新方法，也不会对新类产生影响。为了使其具体化，这里有一个使用复合和转发方法的方法，用以替代 InstrumentedHashSet。注意，实现被分成两部分，类本身和一个可复用的转发类，其中包含所有的转发方法，没有其他内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper class - uses composition in place of inheritance</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstrumentedSet</span><span class="params">(Set&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        addCount += c.size();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reusable forwarding class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;E&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForwardingSet</span><span class="params">(Set&lt;E&gt; s)</span> </span>&#123; <span class="keyword">this</span>.s = s; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; s.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> s.contains(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> s.add(e); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> s.remove(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.containsAll(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.addAll(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.removeAll(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.retainAll(c); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123; <span class="keyword">return</span> s.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123; <span class="keyword">return</span> s.toArray(a); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123; <span class="keyword">return</span> s.equals(o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InstrumentedSet 类的设计是通过 Set 接口来实现的，这个接口可以捕获 HashSet 类的功能。除了健壮外，这个设计非常灵活。InstrumentedSet 类实现了 Set 接口，有一个构造函数，它的参数也是 Set 类型的。实际上，这个类可以将任何一个 Set 转换成另一个 Set，并添加 instrumentation 的功能。基于继承的方法只适用于单个具体类，并且需要为超类中每个受支持的构造函数提供单独的构造函数，与此不同的是，包装器类可用于仪器任何集合实现，并将与任何现有构造函数一起工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Instant&gt; times = <span class="keyword">new</span> InstrumentedSet&lt;&gt;(<span class="keyword">new</span> TreeSet&lt;&gt;(cmp));</span><br><span class="line">Set&lt;E&gt; s = <span class="keyword">new</span> InstrumentedSet&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;(INIT_CAPACITY));</span><br></pre></td></tr></table></figure><p>InstrumentedSet 类甚至还可以用来临时配置一个没有 instrumentation 功能的 Set 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(Set&lt;Dog&gt; dogs)</span> </span>&#123;</span><br><span class="line">InstrumentedSet&lt;Dog&gt; iDogs = <span class="keyword">new</span> InstrumentedSet&lt;&gt;(dogs);</span><br><span class="line">... <span class="comment">// Within this method use iDogs instead of dogs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InstrumentedSet 类被称为包装类，因为每个 InstrumentedSet 实例都包含(「包装」)另一个集合实例。这也称为装饰者模式 [Gamma95]，因为 InstrumentedSet 类通过添加插装来「装饰」一个集合。有时复合和转发的组合被不当地称为委托。严格来说，除非包装器对象将自身传递给包装对象，否则它不是委托</p><p>包装类的缺点很少。一个需要注意的点是：包装类不适合在回调框架中使用，在回调框架中，对象为后续调用(「回调」)将自定义传递给其他对象。因为包装对象不知道它的包装器，所以它传递一个对它自己的引用（this），回调避开包装器。这就是所谓的「自用」问题。有些人担心转发方法调用的性能影响或包装器对象的内存占用影响。这两种方法在实践中都没有多大影响。编写转发方法很麻烦，但是你必须只为每个接口编写一次可复用的转发类，而且可能会为你提供转发类。例如，Guava 为所有的集合接口提供了转发类</p><h2 id="Coad规则"><a href="#Coad规则" class="headerlink" title="Coad规则"></a>Coad规则</h2><p>仅当下列的所有标准被满足时，方可使用继承：</p><p>a.子类表达了”是一个…的特殊类型”，而非”是一个由…所扮演的角色”。</p><p>b子类的一个实例永远不需要转化（transmute）为其它类的一个对象。</p><p>c.子类是对其父类的职责（responsibility）进行扩展，而非重写或废除（nullify）。</p><p>d.子类没有对那些仅作为一个工具类（utility class）的功能进行扩展。</p><p>e.对于一个位于实际的问题域（Problem Domain）的类而言，其子类特指一种角色（role），交易（transaction）或设备（device）。</p><h2 id="继承-组合总结"><a href="#继承-组合总结" class="headerlink" title="继承/组合总结"></a>继承/组合总结</h2><p>1.组合与继承都是重要的重用方法</p><p>2.在OO开发的早期，继承被过度地使用</p><p>3.随着时间的发展，我们发现优先使用组合可以获得重用性与简单性更佳的设计</p><p>4.当然可以通过继承，以扩充（enlarge）可用的组合类集（the set of composable classes）。</p><p>5.因此组合与继承可以一起工作</p><p>6.但是我们的基本法则是：</p><p><strong>优先使用对象组合，而非（类）继承</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用继承实现代码复用很强大的方法。&lt;/p&gt;
&lt;p&gt;在同一个包中由程序员控制子类和超类也是安全的，但是对于普通的具体类进行跨包边界的继承是危险的。&lt;/p&gt;
&lt;p&gt;（本文暂不讨论接口继承）&lt;/p&gt;
&lt;h2 id=&quot;继承-破坏了封装&quot;&gt;&lt;a href=&quot;#继承-破坏了封装&quot; cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux命令行 （二） 运行脚本</title>
    <link href="https://createralan.github.io/2020/04/18/linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>https://createralan.github.io/2020/04/18/linux命令行-（二）-运行脚本/</id>
    <published>2020-04-18T23:18:44.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>首先上例子：</p><ul><li><p>####查看文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% cat my_echo.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">  print(<span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name___ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">  main()</span><br></pre></td></tr></table></figure></li><li><p>####执行文件 ： 解释器 脚本文件 【参数】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% python3 my_echo.py hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>####在文件内添加解释器 </p><p>把这个加在需执行文件的上面来制定解释器</p><p>必须放在第一行 <code>#!</code> ，并使用绝对路径，但如果使用/usr/bin/env ，系统会自动帮你运行环境变量中的解释器等价于写绝对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% #!/usr/bin/env python3</span><br></pre></td></tr></table></figure></li><li><p>####增加可执行权限 （change mode）</p><p>+x 是可执行权限</p><p>-x 也可以减</p><p>还有一种是数字 Owner 7 = 1+2+4  = 可执行 + 可写 + 可读（妙啊！）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% chomd +x my_echo.py</span><br></pre></td></tr></table></figure></li><li><p>####运行脚本（在添加解释器之后）%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% ./my_echo.py hello world!</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>####更改文件名（移动文件） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% mv my_echo.py myecho</span><br></pre></td></tr></table></figure><blockquote><p>cp 复制文件  （cp -r 复制文件夹）</p><p>rm 删除文件（ rm -rf 强制递归删除一切 ）</p></blockquote></li><li><p>####将当前路径追加到环境变量 （不是永久的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% PATH= $PATH:$PWD</span><br></pre></td></tr></table></figure></li><li><p>####上#一步骤将当前路径添加到环境变量后，在任意路径可以执行该python脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% my_echo hello world!</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></li><li><p>####查看该可执行文件所配置的环境变量位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% which my_echo</span><br><span class="line">/Users/xiapazi/cmd2/my_echo</span><br></pre></td></tr></table></figure></li></ul><h2 id="娱乐时间"><a href="#娱乐时间" class="headerlink" title="娱乐时间"></a>娱乐时间</h2><p>-未成年人请勿模仿</p><p>一直输出 ： AMD YES！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% yes</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">y</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">% yes AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">AMD YES !</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面恐怖的开始了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% yes &apos;AMD YES&apos; &gt; amd.txt （无限输入&apos;AMD YES&apos;到amd.txt文件中）</span><br><span class="line">（10s左右的等待时间）</span><br><span class="line">（CTRL+C 停止）</span><br><span class="line">% cat amd.txt | wc -l (查看一共有多少行)</span><br><span class="line">129470008 （超过一亿行了）</span><br><span class="line">% ls -lh</span><br><span class="line">(显示amd.txt已经超过了1个g)</span><br></pre></td></tr></table></figure><p>每秒写100m ，超快~~~</p><p>bye bye 我们还有下期命令行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先上例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;####查看文件内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://createralan.github.io/2020/04/18/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89-%E5%87%8F%E5%B0%91%E7%B1%BB%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    <id>https://createralan.github.io/2020/04/18/高效java-（十二）-减少类的可变性/</id>
    <published>2020-04-18T00:00:00.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:高效java （十二） 减少类的可变性<br>date:2020-04-18 22:13:15<br>tags:java</p><h2 id="categories-java"><a href="#categories-java" class="headerlink" title="categories:[java]"></a>categories:[java]</h2><p><em>An immutable class is simply  a class whole instances cannot be modified . All of the information contained in each instance is fixed for the lifetime of the object , so no changes can ever be observed . The java platform libraies contain many immutable classes , including String ,the boxed primitive classes , and BigInteger and BigDecimal . There are many good reasons for this： Immutable classes are easier to design , implement ,and use than mutable classes , They are less prone to error and are more secure.</em></p><p>不可变类就是一个实例不能被修改的类。每个实例中包含的所有信息在对象的声明周期内都是固定的，因此永远不会观察到任何更改。Java库包含许多不可变的类，包括String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。他们不太容易出错、而且更安全。</p><p>###实现不可变类，请遵循5条规则</p><ul><li><p><strong>不要提供修改对象状态的方法。</strong></p></li><li><p><strong>确保类不能被扩展</strong></p><p>这可以防止无意或恶意的自雷以其对象状态可改变的方式，而损害超类的不可变行为。</p></li><li><p><strong>所有字段用final修饰</strong></p></li><li><p><strong>所有字段为私有</strong></p></li><li><p><strong>确保对任何可变组件的独占访问</strong></p><p>如果你的类有任何引用可变对象的字段，请确保该类的客户端无法获得这些对象的引用。永远不要想提供对象引用的客户端初始化这样的字段，也不要从访问器返回字段。</p></li></ul><p>下面是</p><h3 id="一个比较复杂的例子"><a href="#一个比较复杂的例子" class="headerlink" title="一个比较复杂的例子"></a>一个比较复杂的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Immutable complex number class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Complex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> re;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> im;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Complex</span><span class="params">(<span class="keyword">double</span> re, <span class="keyword">double</span> im)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.re = re;</span><br><span class="line">        <span class="keyword">this</span>.im = im;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">realPart</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">imaginaryPart</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">plus</span><span class="params">(Complex c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(re + c.re, im + c.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">minus</span><span class="params">(Complex c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(re - c.re, im - c.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">times</span><span class="params">(Complex c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(re * c.re - im * c.im, re * c.im + im * c.re);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Complex <span class="title">dividedBy</span><span class="params">(Complex c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = c.re * c.re + c.im * c.im;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Complex))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Complex c = (Complex) o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See page 47 to find out why we use compare instead of ==</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(c.re, re) == <span class="number">0</span> &amp;&amp; Double.compare(c.im, im) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span> * Double.hashCode(re) + Double.hashCode(im);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + re + <span class="string">" + "</span> + im + <span class="string">"i)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类表示一个复数，除了标准的Obejct方法之外，他还为实部和虚部提供访问器，并提供加减乘除。需要注意的是，算术操作如何创建和返回一个新的Complex实例，而不是修改这个实例。这种模式成为泛函方法。因为方法返回对其操作数应用函数为结果，而不是修改它。将其与方法将过程应用于其操作数的过程或命令方式进行对比，使其状态发生变化。注意，方法名是介词（PLUS），而不是动词(ADD)，这无形中就可以看出方法不会改变对象的值。BigInteger 和 BigDecimal类不遵守这个命名约定，导致了许多使用错误。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>一个不可变的对象可以七号处于一种状态，即使创建的状态。如果你确保所有构造函数都建立了类不变量，那么就可以保证这些不变量将一直保持，而你和使用该类的程序员无需再做任何事。</p><ul><li><p><strong>你不仅可以共享不可变对象，而且可以共享它们的内部实现。</strong></p><p>例如，BigInteger类在内部使用符号大小来表示。符号由int表示，大小由int数组表示。negate方法产生一个新的BigInteger，大小相同，符号相反。即使数组是可变的，也不需要复制；新创建的BigInteger指向与原始数组相同的内部数组。</p></li><li><p><strong>不可变对象可以很好的作为其他对象的构建模块</strong></p><p>无论是可变的还是不可变的。如果知道复杂对象的组件对象不会在其内部发生更改，那么维护复杂对象的不变性就会容易得多。这个原则的一个具体的例子是，不可变对象很合适 Map 的键和 Set 的元素：你不必担心它们的值在 Map 或 Set 中发生变化，否则会破坏 Map 或 Set 的不变性。</p></li><li><p><strong>不可变对象自带提供故障原子性</strong></p><p>他们的状态从未改变，所以不可能出现暂时的不一致。</p></li></ul><hr><ul><li><p><strong>不可变类的主要缺点是每个不同的值都需要一个单独的对象。</strong></p><p>创建这些对象的成本可能很高，尤其是如果对象很大的话。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:高效java （十二） 减少类的可变性&lt;br&gt;date:2020-04-18 22:13:15&lt;br&gt;tags:java&lt;/p&gt;
&lt;h2 id=&quot;categories-java&quot;&gt;&lt;a href=&quot;#categories-java&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （十一） 在公共类中使用访问方法而不是公共属性 </title>
    <link href="https://createralan.github.io/2020/04/17/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89-%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E5%85%B1%E5%B1%9E%E6%80%A7/"/>
    <id>https://createralan.github.io/2020/04/17/高效java-（十一）-在公共类中使用访问方法而不是公共属性/</id>
    <published>2020-04-17T14:55:18.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有想过，我为啥要写一个对象实体类，把属性设置为public，就不用再写get、set了！</p><p>像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Degenerate classes like this should not be public!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单！</p><hr><ul><li><p><strong>如果一个类在其包之外是可访问的，则提供访问方法来保留更改类内部表示的灵活性。</strong></p><p>如果一个类暴露其数据属性，那么以后更改其表示形式基本上是没有可能，因为客户端代码可以散布在很多地方！！！</p></li><li><p><strong>如果一个类是包级私有级别的，或者是一个私有类的内部，那么暴露它的数据属性就没有什么本质上的错误–假设它们提供足够描述该类提供的对象。</strong></p><p>在类定义和使用它的客户端代码中，这种方法比访问方法产生更少的视觉混乱。 虽然客户端代码绑定到类的内部表示，但是这些代码仅限于包含该类的包。 如果类的内部表示是可取的，可以在不触碰包外的任何代码的情况下进行更改。 在私有内部类的情况下，更改作用范围进一步限制在封闭类中。Java 平台类库中的几个类违反了公共类不应直接暴露属性的建议。 著名的例子包括 <code>java.awt</code> 包中的 <code>Point</code> 和 <code>Dimension</code> 类。 这些类别应该被视为警示性的示例，而不是模仿的例子。 如条目 67 所述，时至今日，暴露 <code>Dimension</code> 的内部结构的决定仍然导致着严重的性能问题。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，公共类不应该暴露可变属性。 公共类暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有没有想过，我为啥要写一个对象实体类，把属性设置为public，就不用再写get、set了！&lt;/p&gt;
&lt;p&gt;像这样&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （十）使类和成员的可访问性最小化 </title>
    <link href="https://createralan.github.io/2020/04/16/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%8D%81%EF%BC%89%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
    <id>https://createralan.github.io/2020/04/16/高效java-（十）使类和成员的可访问性最小化/</id>
    <published>2020-04-16T14:54:59.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让每个类或成员尽可能地不可访问"><a href="#让每个类或成员尽可能地不可访问" class="headerlink" title="让每个类或成员尽可能地不可访问"></a><strong>让每个类或成员尽可能地不可访问</strong></h2><p>好组件和差组件的最大区别因素：隐藏内部数据和其他实现细节的程度。</p><p>一个设计良好的组件隐藏了它的所有实现细节，干净地将它的 API 与它的实现分离开来。然后，组件只通过它们的 API 进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则</p><p>Java中对于成员（字段、方法、嵌套类、嵌套接口），有<strong>四种可能的访问级别</strong>：</p><ul><li>private 该成员只能在声明它的顶级类内访问</li><li>package-private （默认访问级别，接口除外）成员可以从被声明的包中的任何类中访问</li><li>protected 成员可以从被申明的类的子类中访问</li><li>public 该成员可以从任何地方被访问</li></ul><p>下面是一些在实现类时的一些tip</p><ul><li><p>公共类的实例字段很少情况下采用public 修饰，带有公共可变字段的类通常是不安全的</p></li><li><p>非零长度的数组总是可变的，类具有公共静态final数组字段，或返回一个这样的字符使是错误的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Potential security hole!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>##总结：</p><p>总而言之，应该尽可能地减少程序元素的可访问性（在合理范围内）。 在仔细设计一个最小化的公共 API 之后，你应该防止任何散乱的类，接口或成员成为 API 的一部分。 除了作为常量的公共静态 <code>final</code> 字段之外，公共类不应该有公共字段。 确保 <code>public static final</code> 字段引用的对象是不可变的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;让每个类或成员尽可能地不可访问&quot;&gt;&lt;a href=&quot;#让每个类或成员尽可能地不可访问&quot; class=&quot;headerlink&quot; title=&quot;让每个类或成员尽可能地不可访问&quot;&gt;&lt;/a&gt;&lt;strong&gt;让每个类或成员尽可能地不可访问&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;好
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （九） 考虑实现Compable接口</title>
    <link href="https://createralan.github.io/2020/04/15/%E9%AB%98%E6%95%88java-%EF%BC%88%E4%B9%9D%EF%BC%89-%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Compable%E6%8E%A5%E5%8F%A3/"/>
    <id>https://createralan.github.io/2020/04/15/高效java-（九）-考虑实现Compable接口/</id>
    <published>2020-04-15T21:34:15.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>CompareTo方法并没有在<code>Obejct</code>类中声明。</p><p>它是<code>Comparable</code>接口中唯一的方法。</p><p>它与Object类的equals方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，它是泛型的。通过实现Comparable接口，一个类表明它的实例有一个自然顺序。对实现Comparable接口的对象数组排序非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a)</span><br></pre></td></tr></table></figure><p>CompareTo方法的通用约定：</p><p>　　将此对象与指定的对象按照排序进行比较。 返回值可能为负整数，零或正整数，因为此对象对应小于，等于或大于指定的对象。 如果指定对象的类型与此对象不能进行比较，则引发 <code>ClassCastException</code> 异常。</p><p>　　下面的描述中，符号 sgn(expression) 表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0 和 1。</p><ul><li>实现类必须确保所有 <code>x</code> 和 <code>y</code> 都满足 <code>sgn(x.compareTo(y)) == -sgn(y. compareTo(x))</code>。 （这意味着当且仅当 <code>y.compareTo(x)</code> 抛出异常时，<code>x.compareTo(y)</code> 必须抛出异常。）</li><li>实现类还必须确保该关系是可传递的：<code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code> 意味着 <code>x.compareTo(z) &gt; 0</code>。</li><li>最后，对于所有的 z，实现类必须确保 <code>x.compareTo(y) == 0</code> 意味着 <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>。</li><li>强烈推荐 <code>(x.compareTo(y) == 0) == (x.equals(y))</code>，但不是必需的。 一般来说，任何实现了 <code>Comparable</code> 接口的类违反了这个条件都应该清楚地说明这个事实。 推荐的语言是「注意：这个类有一个自然顺序，与 <code>equals</code> 不一致」。</li></ul><hr><p>　在 Java 8 中 <code>Comparator</code> 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现 <code>compareTo</code> 方法，就像 <code>Comparable</code> 接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序 PhoneNumber 实例的数组速度慢了大约 10％。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是 PhoneNumber 的 <code>compareTo</code> 方法的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparable with comparator construction methods</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&#125;复制ErrorOK!</span><br></pre></td></tr></table></figure><p>　　此实现在类初始化时构建比较器，使用两个比较器构建方法。第一个是 <code>comparingInt</code> 方法。它是一个静态方法，它使用一个键提取器函数式接口（key extractor function）作为参数，将对象引用映射为 int 类型的键，并返回一个根据该键排序的实例的比较器。在前面的示例中，<code>comparingInt</code> 方法使用 lambda 表达式，它从 <code>PhoneNumber</code> 中提取区域代码，并返回一个 <code>Comparator</code>，根据它们的区域代码来排序电话号码。注意，lambda 表达式显式指定了其输入参数的类型 (PhoneNumber pn)。事实证明，在这种情况下，Java 的类型推断功能不够强大，无法自行判断类型，因此我们不得不帮助它以使程序编译。</p><p>　　如果两个电话号码实例具有相同的区号，则需要进一步细化比较，这正是第二个比较器构建方法，即 <code>thenComparingInt</code> 方法做的。 它是 <code>Comparator</code> 上的一个实例方法，接受一个 int 类型键提取器函数式接口（key extractor function）作为参数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的键来打破连接。 你可以按照喜欢的方式多次调用 <code>thenComparingInt</code> 方法，从而产生一个字典顺序。 在上面的例子中，我们将两个调用叠加到 <code>thenComparingInt</code>，产生一个排序，它的二级键是 prefix，而其三级键是 lineNum。 请注意，我们不必指定传递给 <code>thenComparingInt</code> 的任何一个调用的键提取器函数式接口的参数类型：Java 的类型推断足够聪明，可以自己推断出参数的类型。</p><p>　　<code>Comparator</code> 类具有完整的构建方法。对于 long 和 double 基本类型，也有对应的类似于 comparingInt 和 <code>thenComparingInt</code> 的方法，int 版本的方法也可以应用于取值范围小于 int 的类型上，如 short 类型，如 PhoneNumber 实例中所示。对于 double 版本的方法也可以用在 float 类型上。这提供了所有 Java 的基本数字类型的覆盖。</p><p>　　也有对象引用类型的比较器构建方法。静态方法 <code>comparing</code> 有两个重载方式。第一个方法使用键提取器函数式接口并按键的自然顺序。第二种方法是键提取器函数式接口和比较器，用于键的排序。<code>thenComparing</code> 方法有三种重载。第一个重载只需要一个比较器，并使用它来提供一个二级排序。第二次重载只需要一个键提取器函数式接口，并使用键的自然顺序作为二级排序。最后的重载方法同时使用一个键提取器函数式接口和一个比较器来用在提取的键上。</p><p>　　有时，你可能会看到 <code>compareTo</code> 或 <code>compare</code> 方法依赖于两个值之间的差值，如果第一个值小于第二个值，则为负；如果两个值相等则为零，如果第一个值大于，则为正值。这是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BROKEN difference-based comparator - violates transitivity!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.hashCode() - o2.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;复制ErrorOK!</span><br></pre></td></tr></table></figure><p>　　不要使用这种技术！它可能会导致整数最大长度溢出和 IEEE 754 浮点运算失真的危险[JLS 15.20.1,15.21.1]。 此外，由此产生的方法不可能比使用上述技术编写的方法快得多。 使用静态 <code>compare</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator based on static compare method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;复制ErrorOK!</span><br></pre></td></tr></table></figure><p>　　或者使用 <code>Comparator</code> 的构建方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator based on Comparator construction method</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder =</span><br><span class="line">        Comparator.comparingInt(o -&gt; o.hashCode());复制ErrorOK!</span><br></pre></td></tr></table></figure><p>　　总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现 <code>Comparable</code> 接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较 <code>compareTo</code> 方法的实现中的字段值时，请避免使用「&lt;」和「&gt;」运算符。 相反，使用包装类中的静态 <code>compare</code> 方法或 <code>Comparator</code> 接口中的构建方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CompareTo方法并没有在&lt;code&gt;Obejct&lt;/code&gt;类中声明。&lt;/p&gt;
&lt;p&gt;它是&lt;code&gt;Comparable&lt;/code&gt;接口中唯一的方法。&lt;/p&gt;
&lt;p&gt;它与Object类的equals方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （八）谨慎地重写clone方法</title>
    <link href="https://createralan.github.io/2020/04/14/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%85%AB%EF%BC%89%E8%B0%A8%E6%85%8E%E5%9C%B0%E9%87%8D%E5%86%99clone%E6%96%B9%E6%B3%95/"/>
    <id>https://createralan.github.io/2020/04/14/高效java-（八）谨慎地重写clone方法/</id>
    <published>2020-04-14T14:47:09.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cloneable接口不包含任何方法。</strong></p><p>你可能想说 WTF！那它用来做什么？</p><p>​    它决定了Obejct的受保护的clone方法实现的行为：如果一个类实现了Cloneable接口，那么Object的clone方法将返回该对象的逐个属性拷贝；否则会抛出<code>CloneNotSupportedException</code>异常。这是一个非常反常的接口使用，不应该被效仿。通常情况下，实现一个接口用来表示可以为客户做什么。但是对于Cloneable接口，它会修改父类上受保护的方法的行为。</p><p>​    虽然规范并没有说明，但是在实践中，实现Cloneable接口的类希望提供一个正常的公共clone方法。为了实现这一目标，该类以及所有父类必须遵循一个复杂的，不可执行的，稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的：它创建对象而不需要调用构造方法。</p><p>以下是从Object规范中截取的部分：</p><ul><li>对于任何对象，x.clone() != x == true</li><li>x.clone().getClass() =  x.getClass() == true</li><li>x.clone().equals(x) == true</li><li>以上要求为通常情况下的，并不是绝对的</li></ul><p>​    假如你希望在一个类中实现Cloneable接口，它的父类提供了一个行为料号的clone方法。首先调用super.clone。得到的对象僵尸院士的完全功能的复制品。在你的类中声明的任何属性将具有与原始属性相同的值。如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步处理。但请注意，不可变类永远不应该提供clone方法，因为只实惠浪费复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clone method for class with no references to mutable state</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> PhoneNumber <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (PhoneNumber) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();  <span class="comment">// Can't happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为了使这个方法起作用，<code>PhoneNumber</code> 的类声明必须被修改，以表明它实现了 Cloneable 接口。 虽然 Object 类的 clone 方法返回 Object 类，但是这个 clone 方法返回 <code>PhoneNumber</code> 类。 这样做是合法和可取的，因为 Java 支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。 这消除了在客户端转换的需要。 在返回之前，我们必须将 Object 的 super.clone 的结果强制转换为 <code>PhoneNumber</code>，但保证强制转换成功。</p><p>　　super.clone 的调用包含在一个 try-catch 块中。 这是因为 Object 声明了它的 clone 方法来抛出 <code>CloneNotSupportedException</code> 异常，这是一个检查时异常。 由于 <code>PhoneNumber</code> 实现了 Cloneable 接口，所以我们知道调用 super.clone 会成功。 这里引用的需要表明 <code>CloneNotSupportedException</code> 应该是未被检查的</p><p>　　<strong>考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现 Cloneable 接口对于 final 类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone 方法复制。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Cloneable接口不包含任何方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能想说 WTF！那它用来做什么？&lt;/p&gt;
&lt;p&gt;​    它决定了Obejct的受保护的clone方法实现的行为：如果一个类实现了Cloneable接口，那么Object的clone
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （七） 重写 equals 方法</title>
    <link href="https://createralan.github.io/2020/04/12/%E9%AB%98%E6%95%88java-%EF%BC%88%E4%B8%83%EF%BC%89-%E9%87%8D%E5%86%99-equals-%E6%96%B9%E6%B3%95%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <id>https://createralan.github.io/2020/04/12/高效java-（七）-重写-equals-方法时遵守通用约定/</id>
    <published>2020-04-12T11:24:02.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>虽说Obejct类是一个具体的类，但它主要是为了继承而设计的。</p><p>它的所有非final方法都有清晰的约定，如果你不这么做，将会阻止其他依赖于约定的类，与此类一起工作。</p><p><strong>什么情况下需要重写equals方法呢？</strong></p><p>例：当你需要一个逻辑相等的概念，例如Integer或者String，程序员使用equals方法比较值对象的引用，期望发现它们在逻辑上相等。</p><p>当你重写equals方法，Object的规范如下：</p><ul><li><strong>自反性</strong>：对于任何非空引用 x，x.equals(x) 必须返回true</li><li><strong>对称性</strong>：对于任何非空引用x、y，如果且仅当 y.equals(x)返回true时，x.equals(y)必须返回true</li><li><strong>传递性</strong>：对于任何非空引用x、y、z，如果x.equals(y)返回true，y.equals(z) 返回true，则x.equals(z)必须返回true</li><li><strong>一致性</strong>：对于任何非空引用x、y，如果在equals比较中使用的信息没有修改，则x.equals(y)的多次调用必须返回true</li><li><strong>非空性</strong>（这个名字不是官方定义的）：对于任何非空引用，x.equals(null)必须返回false</li></ul><p>编写和测试 equals（和 hashCode）方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌 AutoValue 开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue 框架生成的方法与你自己编写的方法本质上是相同的。</p><p>　　很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成 equals 和 hashCode 方法的功能，但是生成的源代码比使用 AutoValue 框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用 IDE 工具生成 equals(和 hashCode) 方法通常比手动编写它们更可取，因为 IDE 工具不会犯粗心大意的错误，而人类则会。</p><p><strong>除非必须：在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全是你想要的。 如果你确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。</strong></p><hr><h2 id="重写equals方法同时也要重写hashcode方法"><a href="#重写equals方法同时也要重写hashcode方法" class="headerlink" title="重写equals方法同时也要重写hashcode方法"></a>重写equals方法同时也要重写hashcode方法</h2><p><strong>在每个类中，在重写equals时，一定要重写hashcode</strong>。如果不这么做，你的类就违反了hashcode的约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。Object这样规范：</p><ul><li>如果没有修改equals方法中用以比较的信息，在应用程序的一次执行过程中对一个对象重复调用hashcode方法时，它必须始终返回相同的值。在应用程序多次执行过程中，每个执行过程在该对象上获取的结果可以不相同。</li><li>如果像个对象根据equals(Obejct)方法比较是相等的，那么在两个对象上调用hashcode就必须产生的结果是相同的整数</li><li>如果两个对象根据equals(Object)方法比较并不相等，则要求在每个对象上调用hashcode都必须产生不同的结果。但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表的性能</li></ul><h4 id="当无法重写hashcode时，所违反的第二个关键条款：相同的对象必须具有相等的哈希码。"><a href="#当无法重写hashcode时，所违反的第二个关键条款：相同的对象必须具有相等的哈希码。" class="headerlink" title="当无法重写hashcode时，所违反的第二个关键条款：相同的对象必须具有相等的哈希码。"></a>当无法重写hashcode时，所违反的第二个关键条款：相同的对象必须具有相等的哈希码。</h4><p>根据类的equals方法，两个不同的示例可能在逻辑上是相同的，但是对于Object类的hashcode方法，它们知识两个没有什么共同之处的对象。因此，Object类的hashcode方法返回两个看似灰机的数字，而不是按约定要求的两个相等的数字。</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;PhoneNumber, String&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">m.put(<span class="keyword">new</span> PhoneNumber(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>), <span class="string">"Jenny"</span>);</span><br></pre></td></tr></table></figure><p>如果没重写hashcode，你本期望<code>m.get(new PhoneNumber(707, 867, 5309))</code> 方法返回 <code>Jenny</code> 字符串，但是只会返回null。</p><p>注意，这里涉及到两个 <code>PhoneNumber</code> 实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。<code>PhoneNumber</code> 类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把 <code>PhoneNumber</code> 实例保存在了一个哈希桶（ hash bucket）中，但 get 方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为 HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。</p><p> 以下是一个简单的配方：</p><ol><li><p>声明一个 int 类型的变量 result，并将其初始化为对象中第一个重要属性 <code>c</code> 的哈希码，如下面步骤 2.a 中所计算的那样。（回顾条目 10，重要的属性是影响比较相等的领域。）</p></li><li><p>对于对象中剩余的重要属性 <code>f</code>，请执行以下操作：<br>a. 比较属性 <code>f</code> 与属性 <code>c</code> 的 int 类型的哈希码：</p><p>  – i. 如果这个属性是基本类型的，使用 <code>Type.hashCode(f)</code> 方法计算，其中 <code>Type</code> 类是对应属性 <code>f</code> 基本类型的包装类。<br>  – ii. 如果该属性是一个对象引用，并且该类的 equals 方法通过递归调用 equals 来比较该属性，并递归地调用 hashCode 方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用 hashCode。 如果该字段的值为空，则使用 0（也可以使用其他常数，但通常来使用 0 表示）。<br>   – iii. 如果属性 <code>f</code> 是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤 2.b 的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为 0。如果所有元素都很重要，则使用 <code>Arrays.hashCode</code> 方法。</p><p>b. 将步骤 2.a 中属性 c 计算出的哈希码合并为如下结果：<code>result = 31 * result + c;</code></p></li><li><p>返回 result 值。</p></li></ol><p>　　当你写完 hashCode 方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用 AutoValue 框架来生成你的 equals 和 hashCode 方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。</p><p>　　可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在 equals 比较中没有使用的任何属性，否则可能会违反 hashCode 约定的第二条。</p><p>　　步骤 2.b 中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个 String 散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择 31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以 2 相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31 的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：<code>31 * i ==（i &lt;&lt; 5） - i</code>。 现代 JVM 可以自动进行这种优化。</p><p>　　让我们把上述办法应用到 <code>PhoneNumber</code> 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typical hashCode method</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Short.hashCode(areaCode);</span><br><span class="line">    result = <span class="number">31</span> * result + Short.hashCode(prefix);</span><br><span class="line">    result = <span class="number">31</span> * result + Short.hashCode(lineNum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是 <code>PhoneNumber</code> 实例中的三个重要的属性，所以显然相等的 <code>PhoneNumber</code> 实例具有相同的哈希码。 实际上，这个方法是 <code>PhoneNumber</code> 的一个非常好的 hashCode 实现，与 Java 平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。</p><hr><p>总之 ，每次重写equals都必须重写hashcode，否则程序将无法正常运行！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说Obejct类是一个具体的类，但它主要是为了继承而设计的。&lt;/p&gt;
&lt;p&gt;它的所有非final方法都有清晰的约定，如果你不这么做，将会阻止其他依赖于约定的类，与此类一起工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么情况下需要重写equals方法呢？&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux命令行 （一） 基础篇</title>
    <link href="https://createralan.github.io/2020/04/11/linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>https://createralan.github.io/2020/04/11/linux命令行-（一）-基础篇/</id>
    <published>2020-04-11T21:37:38.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>掌握本文中出现的命令行，将可以处理绝大多数的linux命令操作。</p><p>本文中出现的命令一定要熟练掌握，这将是下一篇linux系列的基础</p><h2 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h2><ul><li><p>自言自语 echo</p><ul><li>echo xiapazi</li><li>xiapazi</li><li>echo $PWD</li><li>/root</li></ul></li><li><p>我在哪个目录下 pwd (Print Working Directory)</p><ul><li>pwd</li><li>/root</li></ul></li><li>切换目录 cd<ul><li>cd /Python-3.7.7</li><li>(无返回值)</li></ul></li><li>看看当前目录都有什么 ls<ul><li>ls</li><li>Python-3.7.7 Python-3.7.7.tgz(当前目录下的文件)</li><li>ls - l(列表模式)</li><li>ls  -la （列表模式+隐藏文件）</li><li>ls  -lh (带文件大小)</li></ul></li></ul><h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><ul><li>查看用户手册或帮助 man，通常man更全一些<ul><li>man -pwd</li></ul></li><li>帮助 -h 或 –help<ul><li>pip -h</li><li>pip –help</li></ul></li></ul><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><ul><li>打印文件内容 cat(Concatenate and print files)<ul><li>cat a.txt</li><li>cat a.txt b.txt</li></ul></li><li><p>打印前n行 head</p><ul><li>head a.txt</li><li>(默认打印前10行)</li><li>head -n 5 </li><li>打印前五行</li></ul></li><li><p>打印后n行 tail</p><ul><li>tail a.txt</li><li>(默认打印前10行)</li><li>tail -n 5 a.txt</li><li>打印后五行</li><li>tail -f a.txt</li><li>（打印后10行且跟踪这个文件，如果有新内容就会打印出来） </li></ul></li><li><p>交互浏览 less</p><ul><li>less a.txt</li><li>可以理解为进入到了一个只读模式的vi（vi就是linux下的一种编辑器）</li></ul></li><li><p>内容查找</p><ul><li>在交互模式下 /<ul><li>进入交互模式后 / 之后输入你想要查找的内容</li></ul></li><li>在命令行中 | grep<ul><li>cat a.txt | grep -n 8</li><li>(会显示文件中所有含有8的内容，加了-n之后会显示处于第几行)</li></ul></li></ul></li><li><p>单词统计 | wc（Word，line and byte count）</p><ul><li>cat a.txt | wc</li><li>100 100 292(100行，100个单词，292个字节)</li></ul></li></ul><h2 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h2><ul><li>重定向<ul><li>将输入重定向到文件 &gt;<ul><li>echo hello &gt; hello.txt</li></ul></li><li>将输入重定向追加到文件 &gt;&gt;<ul><li>echo world &gt;&gt; hello.txt</li></ul></li><li>将文件内容重定向至命令行打印出来 &lt;<ul><li>cat &lt;hello.txt</li></ul></li></ul></li><li>管道<ul><li>将前一个的输出作为下一个的输入，形成一个工作流<ul><li>man less | grep sim</li><li>(进入交互模式且查找sim)</li><li>man less |grep -n sim | grep That &gt; that.txt</li><li>(进入交互模式查找sim并显示行号，后在查找包含That，再之后重定向输入到that.txt文件中)</li></ul></li></ul></li></ul><h1 id="概念补充：Unix哲学"><a href="#概念补充：Unix哲学" class="headerlink" title="概念补充：Unix哲学"></a>概念补充：Unix哲学</h1><ul><li>每个程序只做一个事情，并且把这个事情做好</li><li>一个程序的输出可以作为另一个程序的输入（管道），不要输出无关的内容</li><li>编写处理字符流的程序，因为那是通用接口</li><li>编写可以互相协作的程序（因为每个程序只做一件事情，多个程序组合就可以实现复杂的操作）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;掌握本文中出现的命令行，将可以处理绝大多数的linux命令操作。&lt;/p&gt;
&lt;p&gt;本文中出现的命令一定要熟练掌握，这将是下一篇linux系列的基础&lt;/p&gt;
&lt;h2 id=&quot;最常用&quot;&gt;&lt;a href=&quot;#最常用&quot; class=&quot;headerlink&quot; title=&quot;最常用&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （六） 使用try-with-resources代替try-finally</title>
    <link href="https://createralan.github.io/2020/04/11/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%85%AD%EF%BC%89-%E4%BD%BF%E7%94%A8try-with-resources%E4%BB%A3%E6%9B%BFtry-finally/"/>
    <id>https://createralan.github.io/2020/04/11/高效java-（六）-使用try-with-resources代替try-finally/</id>
    <published>2020-04-11T15:03:59.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况我们在关闭资源的时候，会使用try-fianlly来关闭资源。</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去也没什么问题，很多情况下我们也都这么做了</p><p>但是往往有例外，如果在底层物理设备发生故障，我们可能在readline方法的调用发生了异常，且同样原因close也发生了异常。在这种情况下，第二个异常会冲掉第一个异常。在异常栈堆中没有第一个异常的记录，这可能使实际系统的调式非常复杂–因为原因你想要诊断的是第一个异常，虽然可以编写代码来异常这种异常，但是没有人会这么做，太冗长了。</p><p><strong>直到JDK7中主角登场 try-with-resources:</strong></p><p>实现这个构造，资源必须实现AutoCloseable接口，该接口返回为void的close组成。java类库和第三方类库中都大部分都继承或实现了AutoCloseable接口。如果你写的类必须关闭资源，请自行继承。</p><p>下面是实现的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">           <span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">       <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种方式比原始方式更精简，有更好的可读性，而且它们提供了更好的诊断，考虑上面我们说的问题，如果调用readline和close方法都抛出异常，则后一个异常将被抑制。为了保证你真正想看到的异常，可能会抑制多个异常。这些异常没有被抛弃，而是会打印在栈堆中跟踪，并且标注为被抑制了。</p><p><strong>结论</strong></p><p>在处理必须关闭的资源时，使用try-with-resources代替try-finally。</p><blockquote><p>更简洁</p><p>更清晰</p><p>异常更有用</p><p>更不容易出错</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常情况我们在关闭资源的时候，会使用try-fianlly来关闭资源。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效java （六） 避免使用 Finalizer 和 Cleaner 机制</title>
    <link href="https://createralan.github.io/2020/04/11/%E9%AB%98%E6%95%88java-%EF%BC%88%E5%85%AD%EF%BC%89-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-Finalizer-%E5%92%8C-Cleaner-%E6%9C%BA%E5%88%B6/"/>
    <id>https://createralan.github.io/2020/04/11/高效java-（六）-避免使用-Finalizer-和-Cleaner-机制/</id>
    <published>2020-04-11T15:03:59.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效Java（五） 消除过期对象的引用</title>
    <link href="https://createralan.github.io/2020/04/10/%E9%AB%98%E6%95%88Java%EF%BC%88%E4%BA%94-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>https://createralan.github.io/2020/04/10/高效Java（五-消除过期对象的引用/</id>
    <published>2020-04-10T17:49:38.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>在大学时期学CPP的时候 ，总是被垃圾回收机制搞得晕头转向。</p><p>学Java的第一天，老师说以后你的对象在使用完毕以后就<code>自动回收</code>了</p><p>想起那句，比在一起更快乐的事情，莫过于分手了！</p><hr><h3 id="一个简单的栈实现的例子—不被回收的对象"><a href="#一个简单的栈实现的例子—不被回收的对象" class="headerlink" title="一个简单的栈实现的例子—不被回收的对象"></a>一个简单的栈实现的例子—不被回收的对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can you spot the "memory leak"?</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序没有错误，但是在极端情况下，这样可能会导致内存泄漏。</p><p>因为一个栈增长后收缩，那么弹栈出的对象不会被回收，过期引用简单来说就是永远不会解除的引用。</p><p><strong>解决方法：一旦对象引用过期，将他们设置为null。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的另一个好处就是，如果他们随后被错误的引用，程序可以马上跑出空指针异常，也方便程序员定位错误。</p><h3 id="但"><a href="#但" class="headerlink" title="但!"></a>但!</h3><p>这既不是必要的，也不是可取的；它不必要地搞乱了程序。</p><p>清空对象引用应该是例外，而不是规范。</p><p>　那么什么时候应该清空一个引用呢？<code>Stack</code> 类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由 <code>elements</code> 数组的元素组成（对象引用单元，而不是对象本身）。数组中活动部分的元素 (如前面定义的) 被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，<code>elements</code> 数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。</p><p>　　一般来说，<strong>当一个类自己管理内存时，程序员应该警惕内存泄漏问题。</strong> 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p><blockquote><p>　　<strong>另一个常见的内存泄漏来源是缓存。</strong> 一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 <code>WeakHashMap</code> 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，<code>WeakHashMap</code> 才有用。</p><p>　　更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程 (也许是 <code>ScheduledThreadPoolExecutor</code>) 或将新的项添加到缓存时顺便清理。<code>LinkedHashMap</code> 类使用它的 <code>removeEldestEntry</code> 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 <code>java.lang.ref</code>。</p><p>　　第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个 API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在 <code>WeakHashMap</code> 的键（key）中。</p><p>　　因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在大学时期学CPP的时候 ，总是被垃圾回收机制搞得晕头转向。&lt;/p&gt;
&lt;p&gt;学Java的第一天，老师说以后你的对象在使用完毕以后就&lt;code&gt;自动回收&lt;/code&gt;了&lt;/p&gt;
&lt;p&gt;想起那句，比在一起更快乐的事情，莫过于分手了！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一个简单的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效Java（四）避免创建不必要的对象</title>
    <link href="https://createralan.github.io/2020/04/09/%E9%AB%98%E6%95%88Java%EF%BC%88%E5%9B%9B%EF%BC%89%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>https://createralan.github.io/2020/04/09/高效Java（四）避免创建不必要的对象/</id>
    <published>2020-04-09T13:28:03.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p>尽量在需要时重用一个对象而不要创建一个新的相同功能对象，这听上去虽然是一句废话。但是我们在实际场景中往往会忽略掉。本文举两个场景来介绍：</p><p>上例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span></span><br><span class="line">            + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(</span><br><span class="line">            <span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span></span><br><span class="line">            + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：方法2往往会比方法1高几倍</strong></p><hr><p>这个实现的问题在于它依赖于String.matches方法。虽然String.matched检查字符串是否匹配是实现正则表达式最简单的方式，但是不适合用于性能临界的情况下重复使用。原理是它在内部为正则表达式创建了一个Patter示例，并且只使用它一次，之后它就有资格进行垃圾回收回收。创建Pattern是很昂贵的仓做，因此在多次调用的情况下，将它编译为一个Pattern实例是更优秀的做法。</p><h3 id="自动装箱导致的不必要创建对象"><a href="#自动装箱导致的不必要创建对象" class="headerlink" title="自动装箱导致的不必要创建对象"></a>自动装箱导致的不必要创建对象</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个正确的例子，因为java允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。在例子中程序构造了大学2的31方个Long的示例，因为每次往Long类型的sum变量中增加一个long类型构造的示例都要把变量的类型从Long改为long。</p><p>如果我们讲Long  改为 long 数据类型。 这将会省去大量的时间，如这个例子，在机器上运行的时间将会有6.3s减低至0.59秒。</p><hr><p>说在最后：</p><p><strong>这个章节不应该被误解为我们应该尽量避免创建对象，相反，使用构造方法创建和回收小的对象是很廉价的，构造方法只会做很少的显示工作，尤其在JVM上，创建额外的对象以增强程序的清晰度，简单性或功能通常是件好事</strong></p><p><strong>除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据连接。连接成本非常的搞，因此重用这些对象是有意义的。但是一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现在的JVM具有高度优化的垃圾收集器，还是挺厉害的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尽量在需要时重用一个对象而不要创建一个新的相同功能对象，这听上去虽然是一句废话。但是我们在实际场景中往往会忽略掉。本文举两个场景来介绍：&lt;/p&gt;
&lt;p&gt;上例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效Java（三） 实现Singleton 属性</title>
    <link href="https://createralan.github.io/2020/04/08/%E9%AB%98%E6%95%88Java%EF%BC%88%E4%B8%89%EF%BC%89-%E5%AE%9E%E7%8E%B0Singleton-%E5%B1%9E%E6%80%A7/"/>
    <id>https://createralan.github.io/2020/04/08/高效Java（三）-实现Singleton-属性/</id>
    <published>2020-04-08T13:54:57.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>单例是一个仅实例化一次的类。同创表示无状态对象。</strong></p><p>下面介绍一下实现单例化的三种方式：</p><ul><li>私有构造方法只调用一次，来初始化Elvis.INSTANCE属性。缺少一个公告的或受保护的构造方法，来保证全局的唯一性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对所有对象都返回相同的对象引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明单一元素的枚举类，类型公共属性方法，但是更简洁，无偿地提供了序列化机智，并提供了防止多个实例化的坚固保证。<strong>单一元素枚举通常是实现单例的最佳方式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;单例是一个仅实例化一次的类。同创表示无状态对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面介绍一下实现单例化的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有构造方法只调用一次，来初始化Elvis.INSTANCE属性。缺少一个公告的或受保护的构造方法，来保证全局的唯
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高效Java（二） builder模式构造</title>
    <link href="https://createralan.github.io/2020/04/07/%E9%AB%98%E6%95%88Java%EF%BC%88%E4%BA%8C%EF%BC%89builder%E6%A8%A1%E5%BC%8F%E6%9E%84%E9%80%A0/"/>
    <id>https://createralan.github.io/2020/04/07/高效Java（二）builder模式构造/</id>
    <published>2020-04-07T01:31:02.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造方法过多时，建议使用builder模式"><a href="#构造方法过多时，建议使用builder模式" class="headerlink" title="构造方法过多时，建议使用builder模式"></a>构造方法过多时，建议使用builder模式</h3><p>常用的JavaBean缺点：</p><blockquote><p>由于构造方法被分割成了多次调用，所以在构造过程中，JavaBean可能处于不一致的状态。</p><p>导致javabean的方法虽然简单易用，但是在不一致的状态下尝试使用对象可能导致一些错误</p><p>javabean模式排除了让类不可变得可能性，所以需要增加工序以保证线程安全</p></blockquote><hr><p>Builder模式：<strong>结合了可伸缩构造方法模式的安全性和JavaBean模式的可读性</strong></p><p><code>可伸缩构造方法：为各种可选参数单独写构造方法</code></p><p>客户端不需要直接构造所需的对象，而是调用一个包含所有必须参数的构造方法得到一个builder对象。然后调用builder对象的与setter相似的方法来设计可选参数。</p><p>实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories      = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat           = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium        = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings    = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">            calories = val;      </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">           fat = val;           </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">           sodium = val;        </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">           carbohydrate = val;  </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize  = builder.servingSize;</span><br><span class="line">        servings     = builder.servings;</span><br><span class="line">        calories     = builder.calories;</span><br><span class="line">        fat          = builder.fat;</span><br><span class="line">        sodium       = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>NutritionFacts</code> 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">    .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><h3 id="Builder-还非常适合类层次结构"><a href="#Builder-还非常适合类层次结构" class="headerlink" title="Builder 还非常适合类层次结构"></a>Builder 还非常适合类层次结构</h3><p>使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Subclasses must override this method to return "this"</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Pizza.Builder</code> 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 <code>self</code> 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。</p><p>　　这里有两个具体的 <code>Pizza</code> 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calzone</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> sauceInside = <span class="keyword">false</span>; <span class="comment">// Default</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sauceInside</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sauceInside = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Calzone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Calzone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Calzone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，每个子类 builder 中的 <code>build</code> 方法被声明为返回正确的子类：<code>NyPizza.Builder</code> 的 <code>build</code> 方法返回 <code>NyPizza</code>，而 <code>Calzone.Builder</code> 中的 <code>build</code> 方法返回 <code>Calzone</code>。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。</p><p>　　这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 <code>NutritionFacts</code> builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza = <span class="keyword">new</span> NyPizza.Builder(SMALL)</span><br><span class="line">        .addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line">Calzone calzone = <span class="keyword">new</span> Calzone.Builder()</span><br><span class="line">        .addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><hr><p>​          <strong>总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;构造方法过多时，建议使用builder模式&quot;&gt;&lt;a href=&quot;#构造方法过多时，建议使用builder模式&quot; class=&quot;headerlink&quot; title=&quot;构造方法过多时，建议使用builder模式&quot;&gt;&lt;/a&gt;构造方法过多时，建议使用builder模式&lt;/
      
    
    </summary>
    
    
      <category term="java" scheme="https://createralan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>高效Java（一） 静态工厂替代构造方法</title>
    <link href="https://createralan.github.io/2020/04/06/%E9%AB%98%E6%95%88Java-%EF%BC%88%E4%B8%80%EF%BC%89-%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%9B%BF%E4%BB%A3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://createralan.github.io/2020/04/06/高效Java-（一）-静态工厂替代构造方法/</id>
    <published>2020-04-06T21:43:14.000Z</published>
    <updated>2021-03-31T05:53:05.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列内容总结自Effctive-java-3 <a href="https://sjsdfg.github.io/" target="_blank" rel="noopener">https://sjsdfg.github.io/</a></p></blockquote><p><strong><em>静态工厂方法与设计模式中的工厂方法模式不同</em></strong></p><p>普通的创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p><strong>new究竟做了什么？</strong></p><p>当我们使用new来构造一个新的类示例时，其实是告诉JVM我们需要一个新的示例。JVM就会在内存中开辟一个新的空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。</p><p><strong>静态工厂示例</strong>：将基本类型<code>boolean</code>转换为 <code>Boolean</code> 对象引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean flag = Boolean.valueOf(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="静态工厂的优点"><a href="#静态工厂的优点" class="headerlink" title="静态工厂的优点"></a>静态工厂的优点</h3><ul><li><p><strong>与构造方法不同，它们是有名字的</strong></p><p>一个类只能有一个给定签名的构造方法。而静态工厂方法有名字，所以在类中需要具有相同签名的多个构造方法的情况下，可以使用静态工厂替换构造方法</p></li><li><p><strong>与构造方法不同，它们不需要每次调用都创建一个新的对象</strong></p><p>单例的写法大多都是用静态工厂方法来实现的</p></li><li><p><strong>与构造方法不同，可以返回其返回类型的任何子类型对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 这里可以改为 return new Player() / Cooker()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Player extends Person&#123;</span><br><span class="line">&#125;</span><br><span class="line">Class Cooker extends Person&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回对象的类可以根据输入的参数不同而不同</strong></p></li><li><p><strong>在编写包含改方法的类时，返回的对象的类不需要存在</strong></p></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>没有公共或保护构造方法的类不能被子类化</strong></li><li><strong>不方便查找</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列内容总结自Effctive-java-3 &lt;a href=&quot;https://sjsdfg.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sjsdfg.github.io/&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
